#use "code-gen.ml";;

let file_to_string f =
  let ic = open_in f in
  let s = really_input_string ic (in_channel_length ic) in
  close_in ic;
  s;;

let string_to_asts s = List.map Semantics.run_semantics
                         (Tag_Parser.tag_parse_expressions
                            (Reader.read_sexprs s));;

let primitive_names_to_labels = 
  ["boolean?", "is_boolean"; "float?", "is_float"; "integer?", "is_integer"; "pair?", "is_pair";
   "null?", "is_null"; "char?", "is_char"; "vector?", "is_vector"; "string?", "is_string";
   "procedure?", "is_procedure"; "symbol?", "is_symbol"; "string-length", "string_length";
   "string-ref", "string_ref"; "string-set!", "string_set"; "make-string", "make_string";
   "vector-length", "vector_length"; "vector-ref", "vector_ref"; "vector-set!", "vector_set";
   "make-vector", "make_vector"; "symbol->string", "symbol_to_string"; 
   "char->integer", "char_to_integer"; "integer->char", "integer_to_char"; "eq?", "is_eq";
   "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ";
   "car", "_car";
   "cdr", "_cdr";
   "cons", "_cons";
   "set-car!", "set_car";
   "set-cdr!", "set_cdr"; 
   "apply", "_apply"];;
 
let name_to_label name = 
  try
    let pair = List.find (fun (n, l) -> n = l) primitive_names_to_labels in
    match pair with
    |(p_name, p_label) -> p_label
  with e -> name;;

let rec const_eq e1 e2 =
  match e1, e2 with
  | Void, Void -> true
  | (Sexpr s1), (Sexpr s2) -> sexpr_eq s1 s2
  | _ -> false;;

let make_prologue consts_tbl fvars_tbl =
  let get_const_address const = 
    let const_tuple = List.find (fun (c,(_, _)) -> const_eq const c) consts_tbl in
    let offset = (fun (c,(off, _)) -> off) const_tuple in
    "const_tbl+" ^ (string_of_int offset) in
    
  let get_fvar_address fvar =  
    let fvar_name = name_to_label fvar in
    let tuple = List.find (fun (name, index, value) -> name = fvar_name) fvars_tbl in
    match tuple with
    |(name, index, value) -> "FVAR("^(string_of_int index)^")" in

  let make_primitive_closure (prim, label) =
"    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
    mov [" ^ (get_fvar_address prim)  ^ "], rax" in

  let make_constant (c, (a, s)) = s in
  
"
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include \"compiler.s\"

section .bss
malloc_pointer:
    resq 1

section .data
const_tbl:
" ^ (String.concat "\n" (List.map make_constant consts_tbl)) ^ "

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS " ^ get_const_address Void ^ "
%define SOB_NIL_ADDRESS " ^ get_const_address (Sexpr Nil) ^ "
%define SOB_FALSE_ADDRESS " ^ get_const_address (Sexpr (Bool false)) ^ "
%define SOB_TRUE_ADDRESS " ^ get_const_address (Sexpr (Bool true)) ^ "

fvar_tbl:
" ^ (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "

global main
push rbp
mov rbp, rsp
section .text
main:
    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 542525648 ;; MAGIC
    push 0
    MALLOC rax, WORD_SIZE   ; allocate space for 1 address
    mov rdx, SOB_NIL_ADDRESS; address of NIL constant = rdx
    mov [rax],  rdx         ; rax -> NIL_CONST
    push rax
    ;push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    jmp code_fragment
    add rsp, 4*8
    ret 

code_fragment:
    ;our fix for dummy frame
    push rbp
    mov rbp, rsp
    add rbp, 8
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
   " ^ (String.concat "\n" (List.map make_primitive_closure primitive_names_to_labels)) ^ " 
  
   
";;

let epilogue = "
_car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; get the pair
    mov rax, CAR_OF_PAIR(rsi) ;;store the car of the pair in rax

    leave
    ret

_cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; get the pair
    mov rax, CDR_OF_PAIR(rsi) ;; store the cdr of the pair in rax

    leave
    ret

_cons:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; get the car
    mov rdi, PVAR(1) ;; get the cdr
    MAKE_PAIR(rax, rsi, rdi);; create sob T_PAIR from them and store the sob in rax

    leave
    ret

set_car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; get the pair
    mov rdi, PVAR(1) ;; get the new val for car
    mov CAR_OF_PAIR(rsi), rdi ;; set the new val

    mov rax, SOB_VOID_ADDRESS ;; set returns void

    leave
    ret

set_cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; get the pair
    mov rdi, PVAR(1) ;; get the new val for cdr
    mov CDR_OF_PAIR(rsi), rdi ;; set the new val

    mov rax, SOB_VOID_ADDRESS ;; set returns void

    leave
    ret



   _apply:
   
      
        ;; =========================================================
   
        push rbp
        mov rbp, rsp
   
        ; ------------------------
        mov r14,   rbp   ;; save old rbp for frame recycle
        mov r15,   qword[rbp]
   
        mov r13, rbp                     ;; r13 = upper_bound for pushing (last arg pushed)
        mov r12, PARAM_COUNT             ;;
        add r12, 3                       ;; ret, env, arg_num (3)
        shl r12, 3                       ;;
        add r13, r12                     ;; r13 = rbp + ( (3+PARAM_COUNT) * WORD_SIZE)
   
        mov r8,  PARAM_COUNT             ;; r8 = PARAM_COUNT + 3
        add r8,  3                       ;; r8 = partial frame size ( ret, env, arg_num)
        ;; ========================= expand arg list in stack ========================================
        mov r10, PARAM_COUNT
        dec r10
        mov r10, PVAR(r10)   ;; r10 -> first T_PAIR = the ls
     
        cmp r10,  SOB_NIL_ADDRESS        ;; if got '() no_list    
        je .no_list




   
      ;; =========================================== TAKE CARE OF LIST ===========================================



      .get_lower_bound:
   
      mov r12,  rsp     ;; lower bound ( ?) 
    


      ;; now r12 = lower bound, r13 = upper bound
    .push_frame:
      mov r9, CAR_OF_PAIR(r10)       ;; first item in pair
      
      SHIFT_STACK_PUSH r12, r13       ;; push the frame down by 1. 
      sub rbp,  8
     .dilug:
      mov qword [r13 - 8],  r9
      
      inc r8                          ;; increase partial frame size
      add qword [rbp + 24], 1         ;; increase num of args by 1
      mov r10,  CDR_OF_PAIR(r10)      ;; next in pair
      
      cmp r10,  SOB_NIL_ADDRESS
      je .stop_pushing
      jmp .get_lower_bound

    .stop_pushing:
     mov qword [r13], 542525648
     jmp .update_param_count


     ;====================================================================================================vv





















       .no_list:
        mov qword [r13],  542525648 ;; MAGIC   [rbp + (PARAM_COUNT + 3 * WORD_SIZE)] <- MAGIC
        
       .update_param_count:
        mov  r9, PARAM_COUNT             ;; no list, so  
        sub  r9, 2                       ;; num of args is same, minus proc and list
        mov PARAM_COUNT, r9              ;; r9 <- n-2 , THE NEW PARAM_COUNT
   
   
       ;; now need to get rid of the PROCEDURE ARGUMENT
       mov r11,  [rbp + 4 * WORD_SIZE]     ;; r11 = proc = the second optinal arg A0 PROC like + 
   
       ;; get lower bound to overwrite the proc
       mov r12, rbp  ;; r12 <- rbp + 5 * WORD_SIZE = the second optinal arg A1  like 1
       add r12,  40  ;; to last argument (which is the proc)
       ;; r13 is the upper bound

      .B_P:
       SHIFT_STACK_PUSH r12, r13       ;; push the frame down by 1. (rsp is also changed)
       add rsp, WORD_SIZE              ;; prevent RSP from changing
      .A_P:
                                       ;; so  [rbp + 4 * WORD_SIZE] A0 OVERRIDE !!
       sub r13,  WORD_SIZE             ;; update after shifting   
       sub r12,  WORD_SIZE
      

       
       mov r12, rsp         ;; 'old_rbp'
       ; ========== pop frame 2 times, to get rid of extra 'magic' blocks =============
       BEFORE_POP1:
       SHIFT_STACK_POP r12, r13
       FUCK:
       add r12, WORD_SIZE
       add r13, WORD_SIZE
       add rbp, WORD_SIZE


       BEFORE_POP2:
      ; ---------------- second time ---------------------------------------------------
       SHIFT_STACK_POP r12, r13
       add r12, WORD_SIZE
       add r13, WORD_SIZE
       add rbp, WORD_SIZE
       .AFTER:
       


       CLOSURE_CODE rsi, r11
       CLOSURE_ENV rdi,  r11
       mov [rsp + 2 * WORD_SIZE],  rdi
       pop rbp
       jmp rsi


";;


(* 

  
    

 *)



exception X_missing_input_file;;

try
  let infile = Sys.argv.(1) in
  let code = (file_to_string "stdlib.scm") ^ (file_to_string infile) in
  let asts = string_to_asts code in
  let consts_tbl = Code_Gen.make_consts_tbl asts in
  let fvars_tbl = Code_Gen.make_fvars_tbl primitive_names_to_labels asts in
  let generate = Code_Gen.generate consts_tbl fvars_tbl in
  let code_fragment = String.concat "\n\n"
                        (List.map
                           (fun ast -> "   ;our_code\n"^ (generate ast 1 0) ^ "\n   ;here\n call write_sob_if_not_void\n")
                           asts) in
                           
  let provided_primitives = file_to_string "prims.s" in
                   
  print_string ((make_prologue consts_tbl fvars_tbl)  ^
                  code_fragment ^ "
add rsp, 5*8 ;; MAGIC SO 5*8
pop rbp
ret\n" ^
                    provided_primitives ^ "\n" ^ epilogue)

with Invalid_argument(x) -> raise X_missing_input_file;;
