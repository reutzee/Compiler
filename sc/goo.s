
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
malloc_pointer:
    resq 1

section .data
test: db 'number is %d', 10, 0
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_BOOL(0)
MAKE_BOOL(1)
MAKE_LITERAL_INT(1)
MAKE_LITERAL_INT(2)
MAKE_LITERAL_INT(3)
MAKE_LITERAL_STRING "alona"
MAKE_LITERAL_SYMBOL(const_tbl+33)
MAKE_LITERAL_INT(4)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

fvar_tbl:
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED

global main
push rbp
mov rbp, rsp
section .text
main:
    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push SOB_NIL_ADDRESS ;; MAGIC
    push 0
    MALLOC rax, WORD_SIZE   ; allocate space for 1 address
    mov rdx, SOB_NIL_ADDRESS; address of NIL constant = rdx
    mov [rax],  rdx         ; rax -> NIL_CONST
    push rax
    ;push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    jmp code_fragment
    add rsp, 5*8
    ret 

code_fragment:
    ;our fix for dummy frame
    push rbp
    mov rbp, rsp
    add rbp, 8
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
       MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [FVAR(0)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [FVAR(1)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [FVAR(2)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [FVAR(3)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [FVAR(4)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [FVAR(5)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_vector)
    mov [FVAR(6)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [FVAR(7)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [FVAR(8)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [FVAR(9)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [FVAR(10)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [FVAR(11)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [FVAR(12)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [FVAR(13)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_length)
    mov [FVAR(14)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_ref)
    mov [FVAR(15)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_set)
    mov [FVAR(16)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_vector)
    mov [FVAR(17)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [FVAR(18)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [FVAR(19)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [FVAR(20)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [FVAR(21)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [FVAR(22)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [FVAR(23)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [FVAR(24)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [FVAR(25)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [FVAR(26)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [FVAR(27)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, _car)
    mov [FVAR(28)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, _cdr)
    mov [FVAR(29)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, _cons)
    mov [FVAR(30)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
    mov [FVAR(31)], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
    mov [FVAR(32)], rax 
  
   
   ;our_code

          LambdaSimple_0_2:

          mov rdi,  2                         ; rbx =size of ExtEnv
          mov rax, WORD_SIZE
          mul rdi   ;  rax <- WORD_SIZE * EXT_ENV_SIZE 
          MALLOC rbx, rax                                               ; rbx -> ExtEnv
          mov rsi, rbx                                                  ; keep ExtEnv pointer for later
          mov rcx, 0                                                    ; for index
          mov rax, qword [rbp + 2 * WORD_SIZE]                          ; rax -> ENV
        
        copy_minors_0_2:
          
          cmp rcx, 1                      ; compare rcx to size of ENV
          je end_copy_minors_0_2                                            ; if equal, loop is done
          mov rdx, qword [rax + rcx * WORD_SIZE]                        ; rdx = ENV[rcx]
          mov [rbx + (rcx + 1) * WORD_SIZE], rdx                        ; copy pointer to the EXT_ENV
          inc rcx
          jmp copy_minors_0_2

        end_copy_minors_0_2:
          mov rdi,  qword 0
          mov rax, WORD_SIZE
          mul rdi   ; rax <- num_params * WORD_SIZE
          MALLOC rax, rax                                                      ; rax -> param_vector
          
          mov qword [rbx], rax                                                 ; ExtEnv[0] -> param_vector
          mov rcx,  0 
          mov rbx, [rbx]                                ;now point to the 0th vector

        copy_param_0_2:
          cmp rcx,  qword 0
          je allocate_closure_0_2
          mov rax,  qword [rbp + (rcx + 4) * WORD_SIZE] ; rax = param n
          mov qword [rbx + rcx * WORD_SIZE], rax        ; copy param to new vector
          inc rcx
          jmp copy_param_0_2

        allocate_closure_0_2:
          MAKE_CLOSURE (rax, rsi, Lcode_0_2)
          jmp Lcont_0_2

        Lcode_0_2:
          push rbp
          mov rbp, rsp
          
            LambdaOpt_1_3:
  
            mov rdi,  3                         ; rbx =size of ExtEnv
            mov rax, WORD_SIZE
            mul rdi   ;  rax <- WORD_SIZE * EXT_ENV_SIZE 
            MALLOC rbx, rax                                               ; rbx -> ExtEnv
            mov rsi, rbx                                                  ; keep ExtEnv pointer for later
            mov rcx, 0                                                    ; for index
            mov rax, qword [rbp + 2 * WORD_SIZE]                          ; rax -> ENV
          
          copy_minors_1_3:
            
            cmp rcx, 2                      ; compare rcx to size of ENV
            je end_copy_minors_1_3                                            ; if equal, loop is done
            mov rdx, qword [rax + rcx * WORD_SIZE]                        ; rdx = ENV[rcx]
            mov [rbx + (rcx + 1) * WORD_SIZE], rdx                        ; copy pointer to the EXT_ENV
            inc rcx
            jmp copy_minors_1_3
  
          end_copy_minors_1_3:
            mov rdi,  qword 2
            mov rax, WORD_SIZE
            mul rdi   ; rax <- num_params * WORD_SIZE
            MALLOC rax, rax                                                      ; rax -> param_vector
            
            mov qword [rbx], rax                                                 ; ExtEnv[0] -> param_vector
            mov rcx,  0 
            mov rbx, [rbx]                                ;now point to the 0th vector
  
          copy_param_1_3:
            cmp rcx,  qword 2
            je allocate_closure_1_3
            mov rax,  qword [rbp + (rcx + 4) * WORD_SIZE] ; rax = param n
            mov qword [rbx + rcx * WORD_SIZE], rax        ; copy param to new vector
            inc rcx
            jmp copy_param_1_3
  
          allocate_closure_1_3:
            MAKE_CLOSURE (rax, rsi, Lcode_1_3)
            jmp Lcont_1_3
  
          Lcode_1_3:
            push rbp
            mov rbp, rsp
            ;; ----- ADJUST STACK IF NEEDED ----- ;;
            ;; r9, r13 pointers on var - the optional
            mov r9, qword [rbp + (4 * WORD_SIZE) + (WORD_SIZE * 1)]
            mov r13, qword [rbp + (4 * WORD_SIZE) + (WORD_SIZE * 1)]

            mov r11, SOB_NIL_ADDRESS ;; FOR CREATE LIST
            ;; if we have there magic - means no optional so skip and goto Lcont (act like simple)
            cmp r9, SOB_NIL_ADDRESS
            je override_with_nil_1_3
            
            ;; else - count the optionals and then create from them list 
            ;; count the optionals, r10 is the counter
            mov r10, 0
            
            count_opt_1_3:
            cmp r13, SOB_NIL_ADDRESS
            je create_list_1_3
            inc r10 
            mov r13, [rbp + (4 * WORD_SIZE) + (WORD_SIZE * 1) + WORD_SIZE * r10]
            jmp count_opt_1_3

            ;; create list by count length
            ;; r12 holds the list
            ;; r10 is our counter
            create_list_1_3:
            cmp r10, 0
            jz override_var_1_3
            dec r10
            mov r14, [rbp + (4 * WORD_SIZE) + (WORD_SIZE * 1) + (WORD_SIZE * r10)]
            MAKE_PAIR(r12, r14, r11)
            mov r11, r12
            jmp create_list_1_3
            
            ;; override var by putting there our list of the optinals
            override_var_1_3:
            mov qword [rbp + (4 * WORD_SIZE) + (WORD_SIZE * 1)], r12
            jmp apply_body_1_3

            override_with_nil_1_3:
            mov qword [rbp + (4 * WORD_SIZE) + (WORD_SIZE * 1)], SOB_NIL_ADDRESS
apply_body_1_3:
            
          LambdaSimple_2_4:

          mov rdi,  4                         ; rbx =size of ExtEnv
          mov rax, WORD_SIZE
          mul rdi   ;  rax <- WORD_SIZE * EXT_ENV_SIZE 
          MALLOC rbx, rax                                               ; rbx -> ExtEnv
          mov rsi, rbx                                                  ; keep ExtEnv pointer for later
          mov rcx, 0                                                    ; for index
          mov rax, qword [rbp + 2 * WORD_SIZE]                          ; rax -> ENV
        
        copy_minors_2_4:
          
          cmp rcx, 3                      ; compare rcx to size of ENV
          je end_copy_minors_2_4                                            ; if equal, loop is done
          mov rdx, qword [rax + rcx * WORD_SIZE]                        ; rdx = ENV[rcx]
          mov [rbx + (rcx + 1) * WORD_SIZE], rdx                        ; copy pointer to the EXT_ENV
          inc rcx
          jmp copy_minors_2_4

        end_copy_minors_2_4:
          mov rdi,  qword 2
          mov rax, WORD_SIZE
          mul rdi   ; rax <- num_params * WORD_SIZE
          MALLOC rax, rax                                                      ; rax -> param_vector
          
          mov qword [rbx], rax                                                 ; ExtEnv[0] -> param_vector
          mov rcx,  0 
          mov rbx, [rbx]                                ;now point to the 0th vector

        copy_param_2_4:
          cmp rcx,  qword 2
          je allocate_closure_2_4
          mov rax,  qword [rbp + (rcx + 4) * WORD_SIZE] ; rax = param n
          mov qword [rbx + rcx * WORD_SIZE], rax        ; copy param to new vector
          inc rcx
          jmp copy_param_2_4

        allocate_closure_2_4:
          MAKE_CLOSURE (rax, rsi, Lcode_2_4)
          jmp Lcont_2_4

        Lcode_2_4:
          push rbp
          mov rbp, rsp
          push SOB_NIL_ADDRESS ;; MAGIC
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
push rax ;; finish take care of arg
push 1 ;;push arg count
mov rax, [FVAR(4)]

mov rdx, rax ;;save the closure on rbx
CLOSURE_ENV rax, rdx ;;in rax we got env
push rax ;;push rax->env
CLOSURE_CODE rcx, rdx ;;in rcx we got code
call rcx ;;call rax->code
add rsp, 8*1 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx * 8
add rsp, rbx ;;pop _args
add rsp, 8 ;; CLEAN MAGIC

cmp rax, SOB_FALSE_ADDRESS
je Lelse4
push SOB_NIL_ADDRESS ;; MAGIC
mov rax, qword [rbp + WORD_SIZE * (4 + 0)]
push rax ;; finish take care of arg
push SOB_NIL_ADDRESS ;; MAGIC
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
push rax ;; finish take care of arg
push SOB_NIL_ADDRESS ;; MAGIC
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
push rax ;; finish take care of arg
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
push rax ;; finish take care of arg
push 2 ;;push arg count
mov rax, [FVAR(22)]

mov rdx, rax ;;save the closure on rbx
CLOSURE_ENV rax, rdx ;;in rax we got env
push rax ;;push rax->env
CLOSURE_CODE rcx, rdx ;;in rcx we got code
call rcx ;;call rax->code
add rsp, 8*1 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx * 8
add rsp, rbx ;;pop _args
add rsp, 8 ;; CLEAN MAGIC
push rax ;; finish take care of arg
push 2 ;;push arg count
mov rax, [FVAR(22)]

mov rdx, rax ;;save the closure on rbx
CLOSURE_ENV rax, rdx ;;in rax we got env
push rax ;;push rax->env
CLOSURE_CODE rcx, rdx ;;in rcx we got code
call rcx ;;call rax->code
add rsp, 8*1 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx * 8
add rsp, rbx ;;pop _args
add rsp, 8 ;; CLEAN MAGIC
push rax ;; finish take care of arg
push 2 ;;push arg count
mov rax, [FVAR(22)]

mov rdx, rax ;;save the closure on rbx
CLOSURE_ENV rax, rdx ;;in rax we got env
push rax ;;push rax->env
CLOSURE_CODE rcx, rdx ;;in rcx we got code
call rcx ;;call rax->code
add rsp, 8*1 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx * 8
add rsp, rbx ;;pop _args
add rsp, 8 ;; CLEAN MAGIC

jmp Lexit3
Lelse4:
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]

Lexit3:

          leave
          ret
        Lcont_2_4:



          
            leave
            ret
          Lcont_1_3:


  
            
          leave
          ret
        Lcont_0_2:



          
mov qword [FVAR(33)], rax
mov rax, SOB_VOID_ADDRESS

   ;here
 call write_sob_if_not_void


   ;our_code
push SOB_NIL_ADDRESS ;; MAGIC
mov rax, const_tbl+56
push rax ;; finish take care of arg
push 1 ;;push arg count
push SOB_NIL_ADDRESS ;; MAGIC
mov rax, const_tbl+47
push rax ;; finish take care of arg
mov rax, const_tbl+24
push rax ;; finish take care of arg
push 2 ;;push arg count
push SOB_NIL_ADDRESS ;; MAGIC
mov rax, const_tbl+15
push rax ;; finish take care of arg
mov rax, const_tbl+6
push rax ;; finish take care of arg
push 2 ;;push arg count
mov rax, [FVAR(33)]

mov rdx, rax ;;save the closure on rbx
CLOSURE_ENV rax, rdx ;;in rax we got env
push rax ;;push rax->env
CLOSURE_CODE rcx, rdx ;;in rcx we got code
call rcx ;;call rax->code
add rsp, 8*1 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx * 8
add rsp, rbx ;;pop _args
add rsp, 8 ;; CLEAN MAGIC

mov rdx, rax ;;save the closure on rbx
CLOSURE_ENV rax, rdx ;;in rax we got env
push rax ;;push rax->env
CLOSURE_CODE rcx, rdx ;;in rcx we got code
call rcx ;;call rax->code
add rsp, 8*1 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx * 8
add rsp, rbx ;;pop _args
add rsp, 8 ;; CLEAN MAGIC

mov rdx, rax ;;save the closure on rbx
CLOSURE_ENV rax, rdx ;;in rax we got env
push rax ;;push rax->env
CLOSURE_CODE rcx, rdx ;;in rcx we got code
call rcx ;;call rax->code
add rsp, 8*1 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx * 8
add rsp, rbx ;;pop _args
add rsp, 8 ;; CLEAN MAGIC

   ;here
 call write_sob_if_not_void

add rsp, 5*8 ;; MAGIC SO 5*8
pop rbp
ret
is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_vector:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_VECTOR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

vector_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    VECTOR_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

vector_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    VECTOR_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 3
    add rsi, rdi

    mov rax, [rsi]

    leave
    ret

vector_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    VECTOR_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 3
    add rsi, rdi

    mov rdi, PVAR(2)
    mov [rsi], rdi
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_vector:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    

    MAKE_VECTOR rax, rsi, rdi

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

.loop:
    cmp rcx, 0
    je .end
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    dec rcx
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret
bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 0
    je .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret



_car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; get the pair
    mov rax, CAR_OF_PAIR(rsi) ;;store the car of the pair in rax

    leave
    ret

_cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; get the pair
    mov rax, CDR_OF_PAIR(rsi) ;; store the cdr of the pair in rax

    leave
    ret

_cons:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; get the car
    mov rdi, PVAR(1) ;; get the cdr
    MAKE_PAIR(rax, rsi, rdi);; create sob T_PAIR from them and store the sob in rax

    leave
    ret

set_car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; get the pair
    mov rdi, PVAR(1) ;; get the new val for car
    mov CAR_OF_PAIR(rsi), rdi ;; set the new val

    mov rax, SOB_VOID_ADDRESS ;; set returns void

    leave
    ret

set_cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) ;; get the pair
    mov rdi, PVAR(1) ;; get the new val for cdr
    mov CDR_OF_PAIR(rsi), rdi ;; set the new val

    mov rax, SOB_VOID_ADDRESS ;; set returns void

    leave
    ret
